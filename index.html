<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <link rel="icon" type="image/x-icon" href="assets/favicon.jpg" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.1.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Varela+Round" rel="stylesheet" />
        <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <header class="masthead1"></header>
        <div id="wrapper" class="lock-padding">
        <nav class="lock-padding navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
            <div class="container px-4 px-lg-5">
                <a class="navbar-brand" href="#page-top">Python one</a>
            </div>
        </nav>
        <!-- Masthead-->
        <!-- About-->
        <section class="about-section text-center" id="about">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-lg-8">
                        <h2 class="text-white mb-4">First lesson of Python</h2>
                        <p class="text-white-50 text-animation animate">
                            Давай разберем эти темы по порядку, чтобы было понятно даже новичку. Мы поговорим про структуры данных, алгоритмы, типы данных в Python, сложность операций, и как это все использовать на практике.

### 1. Что такое структуры данных?

Структуры данных — это способы организации и хранения данных для эффективной работы с ними. Представь, что у тебя есть набор инструментов (например, ящики для хранения вещей), и каждый из них создан для разных целей — некоторые удобны для быстрого доступа, другие — для упорядочивания.

#### Основные структуры данных:
- Stack (Стек) — структура, работающая по принципу LIFO (Last In, First Out), что означает: "последний зашел — первый вышел". Представь стопку тарелок: ты можешь взять только ту, которая сверху.
    - Операции: добавление в стек (push), удаление из стека (pop).
    - Пример: В Python стек реализуется с помощью списка:</p>
    <pre><code>stack = []
      stack.append(1)  # push
      stack.append(2)
      print(stack.pop())  # pop, вернет 2
    </code></pre>    
      
      
- <p> Queue (Очередь) — структура, работающая по принципу FIFO (First In, First Out), что означает: "первый зашел — первый вышел". Представь очередь в магазине.
    - Операции: добавление в очередь (enqueue), удаление из очереди (dequeue).
    - Пример:</p>
     <pre><code>
        from collections import deque
        queue = deque()
        queue.append(1)  # enqueue
        queue.append(2)
        print(queue.popleft())  # dequeue, вернет 1
     </code></pre>
      
      
<p>- Deque (Двухсторонняя очередь) — расширенная версия очереди, где можно добавлять и удалять элементы с обеих сторон.
    - Операции: добавление/удаление в начале и в конце.
    - Пример:</p>
     <pre>
        <code>
            deque = deque()
            deque.append(1)  # добавляем в конец
            deque.appendleft(2)  # добавляем в начало
            deque.pop()  # удаляем из конца
            deque.popleft()  # удаляем из начала
        </code>
     </pre>
      
      
     <p>- List (Список) — это упорядоченная последовательность элементов. В Python список — изменяемый тип данных, и в нем можно хранить любые объекты.
    - Пример:</p>
     <pre>
        <code>
            my_list = [1, 2, 3]
            my_list.append(4)  # добавляем элемент
            my_list[0] = 10  # изменяем элемент по индексу
        </code>
     </pre>
      
      
<p>- Hash table (Хэш-таблица) — это структура данных, которая позволяет быстро находить элемент по ключу. В Python хэш-таблица реализована в виде словаря (dict).
    - Пример:</p>
     <pre>
        <code>
            my_dict = {'apple': 1, 'banana': 2}
            print(my_dict['apple'])  # доступ по ключу, вернет 1
        </code>
     </pre>
      
      
<p>### 2. Алгоритмы сортировки
    Алгоритмы — это последовательность шагов, которые решают задачу или проблему. 
    Алгоритмы могут быть использованы для сортировки, поиска, обработки данных и многого другого
    

Алгоритмы сортировки используются для упорядочивания данных.

- Пузырьковая сортировка (Bubble Sort): Этот алгоритм последовательно сравнивает пары элементов и меняет их местами, если они стоят не в правильном порядке.
    - Пример:</p>
     <pre>
        <code>
            def bubble_sort(arr):
            n = len(arr)
            for i in range(n):
                for j in range(0, n-i-1):
                    if arr[j] > arr[j+1]:
                        arr[j], arr[j+1] = arr[j+1], arr[j]
            return arr

            print(bubble_sort([64, 34, 25, 12, 22, 11, 90]))
        </code>
     </pre>
      
      
<p>- Сортировка вставками (Insertion Sort): Алгоритм постепенно строит отсортированную последовательность, вставляя элементы в нужное место.
    - Пример:</p>
    <pre>
        <code>
            def insertion_sort(arr):
            for i in range(1, len(arr)):
                key = arr[i]
                j = i - 1
                while j >= 0 and key < arr[j]:
                    arr[j + 1] = arr[j]
                    j -= 1
                arr[j + 1] = key
            return arr

            print(insertion_sort([64, 34, 25, 12, 22, 11, 90]))
        </code>
    </pre> 
      
      
<p>### 3. Алгоритмы поиска

- Линейный поиск: Алгоритм перебирает элементы списка по одному, пока не найдет нужный.
    - Пример:</p>
    <pre>
        <code>
    
            def linear_search(arr, x):
                for i in range(len(arr)):
                    if arr[i] == x:
                        return i
                return -1

            print(linear_search([1, 2, 3, 4, 5], 3))  # вернет 2 (индекс)
        </code>
    </pre>
    
    <p>- Бинарный поиск: Этот алгоритм работает только на отсортированных массивах. Он делит массив пополам и проверяет, в какой части массива находится искомый элемент.
        - Пример:</p>
        <pre>
            <code>
                def binary_search(arr, x):
                low, high = 0, len(arr) - 1
                while low <= high:
                    mid = (low + high) // 2
                    if arr[mid] < x:
                        low = mid + 1
                    elif arr[mid] > x:
                        high = mid - 1
                    else:
                        return mid
                return -1
      
                print(binary_search([1, 2, 3, 4, 5], 3))  # вернет 2 (индекс)      
            </code>
        </pre>
        <p> 4. Big O notation (Оценка сложности)
            Чтобы измерить эффективность алгоритмов, используют Big O notation (О-большое). 
            Это способ описать, как растет время выполнения или объем памяти по мере увеличения количества данных.

            Big O — это способ описания времени выполнения алгоритма в зависимости от размера входных данных. Например:
            - O(1) — постоянное время (например, доступ к элементу по индексу).
            - O(n) — линейное время (например, линейный поиск, где нужно просмотреть каждый элемент).
            - O(log n) — логарифмическое время (например, бинарный поиск, где количество проверяемых элементов уменьшается вдвое на каждом шаге).
            
            #### Сложность операций:
            - Stack:
              - Добавление/удаление элемента: O(1).
            - Queue:
              - Добавление/удаление элемента: O(1).
            - Deque:
              - Добавление/удаление в начале и в конце: O(1).
            - List:
              - Доступ по индексу: O(1).
              - Вставка/удаление элемента: O(n) (в худшем случае).
            - Hash table (dict):
              - Доступ по ключу: O(1) в среднем, O(n) в худшем случае (если все ключи попали в одно место).</p>
            <p>### 5. Типы данных в Python
        - str — строка (последовательность символов).</p>
        <pre>
            <code>
                my_str = "hello"
            </code>
        </pre>
        <p>- int — целое число.</p>
        <pre>
            <code>
                my_int = 42
            </code>
        </pre>
        <p>- float — число с плавающей точкой.</p>
        <pre>
            <code>
                my_float = 3.14
            </code>
        </pre>
        <p>- bool — логический тип (True или False).</p>
        <pre>
            <code>
                is_active = True
            </code>
        </pre>
        <p>- byte, bytearray — работа с последовательностью байтов.</p>
        <pre>
            <code>
                my_byte = b'hello'
            </code>
        </pre>
        <p>- dict — словарь (ассоциативный массив).</p>
        <pre>
            <code>
                my_dict = {'key': 'value'}
            </code>
        </pre>
        <p>- list — список (изменяемая последовательность элементов).</p>
        <pre>
            <code>
                my_list = [1, 2, 3]
            </code>
        </pre>
        <p>- tuple — кортеж (неизменяемая последовательность элементов).</p>
        <pre>
            <code>  my_tuple = (1, 2, 3)
            </code>
        </pre>
        <p>- set — множество (уникальные элементы).</p>
        <pre>
            <code>
                my_set = {1, 2, 3}
            </code>
        </pre>
        <p> Big O для операций чтение/запись для Dict, List, Tuple, Set

            Big O описывает, сколько времени или памяти потребуется для выполнения операции в зависимости от размера данных. Чем меньше это время, тем лучше.
            
            #### Dict (словарь):
            - Чтение по ключу: O(1) — это означает, что ты всегда можешь быстро найти значение по ключу, независимо от размера словаря.
            - Запись (добавление или обновление элемента): O(1) — добавить элемент в словарь или обновить существующий также быстро.
        </p>
        <pre>
            <code>
                my_dict = {"a": 1, "b": 2}
                print(my_dict["a"])  # Чтение - O(1)
                my_dict["c"] = 3  # Запись - O(1)
            </code>
        </pre>
        <p>### 6. Big O для операций чтение/запись для Dict, List, Tuple, Set

            Big O описывает, сколько времени или памяти потребуется для выполнения операции в зависимости от размера данных. Чем меньше это время, тем лучше.
            
            #### Dict (словарь):
            - Чтение по ключу: O(1) — это означает, что ты всегда можешь быстро найти значение по ключу, независимо от размера словаря.
            - Запись (добавление или обновление элемента): O(1) — добавить элемент в словарь или обновить существующий также быстро.
        </p>
        <pre>
            <code>
                my_dict = {"a": 1, "b": 2}
                print(my_dict["a"])  # Чтение - O(1)
                my_dict["c"] = 3  # Запись - O(1)
            </code>
        </pre>
        <p> List (список):
            - Чтение по индексу: O(1) — если ты знаешь индекс элемента, можешь его быстро получить.
            - Запись (вставка или удаление):
              - В конец списка: O(1) — быстро.
              - В начало или середину: O(n) — медленно, так как придётся двигать элементы.            
        </p>
        <pre>
            <code>
                my_list = [1, 2, 3]
                print(my_list[0])  # Чтение - O(1)
                my_list.append(4)  # Запись в конец - O(1)
                my_list.insert(0, 0)  # Запись в начало - O(n)
            </code>
        </pre>
        <p> Tuple (кортеж):
            - Чтение по индексу: O(1) — так же, как и у списка.
            - Запись: Нельзя, так как кортеж неизменяем.           
        </p>
        <pre>
            <code>
                my_tuple = (1, 2, 3)
                print(my_tuple[1])  # Чтение - O(1)
                # my_tuple[1] = 0  # Ошибка! Кортеж неизменяем
            </code>
        </pre>
        <p> Set (множество):
            - Чтение (проверка наличия элемента): O(1) — легко проверить, есть ли элемент в множестве.
            - Запись (добавление элемента): O(1) — добавление элемента быстро.           
        </p>
        <pre>
            <code>
                my_set = {1, 2, 3}
                print(2 in my_set)  # Чтение - O(1)
                my_set.add(4)  # Запись - O(1)
            </code>
        </pre>
        <p>###7. Comprehension для Dict, List, Set

            Comprehension — это способ создания новых списков, словарей или множеств на основе уже существующих коллекций, но с более компактным синтаксисом.
            
            #### List comprehension (списки):
            Быстрый способ создания списка.
        </p>
        <pre>
            <code>
                squares = [x*x for x in range(5)]  # Создаёт список квадратов чисел от 0 до 4
                print(squares)  # [0, 1, 4, 9, 16]
            </code>
        </pre>
        <p>###7. Comprehension для Dict, List, Set

            Comprehension — это способ создания новых списков, словарей или множеств на основе уже существующих коллекций, но с более компактным синтаксисом.
            
            #### List comprehension (списки):
            Быстрый способ создания списка.
        </p>
        <pre>
            <code>
                squares = [x*x for x in range(5)]  # Создаёт список квадратов чисел от 0 до 4
                print(squares)  # [0, 1, 4, 9, 16]
            </code>
        </pre>
        <p>
            Dict comprehension (словари):То же самое, только для создания словарей.
        </p>
        <pre>
            <code>
                squares_dict = {x: x*x for x in range(5)}  # Ключ — число, значение — его квадрат
                print(squares_dict)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
            </code>
        </pre>
        <p>Set comprehension (множества):
            Создание множества с помощью comprehension.
        </p>
        <pre>
            <code>
                unique_squares = {x*x for x in range(5)}  # Создаёт множество
                print(unique_squares)  # {0, 1, 4, 9, 16}
            </code>
        </pre>

        <p>### 8. Изменяемые/неизменяемые типы данных

            - Изменяемые типы данных: list, dict, set, bytearray. Эти типы могут быть изменены после создания.
            - Неизменяемые типы данных: int, float, str, tuple, bool, bytes. Эти типы нельзя изменить после создания.
        </p>
        <p>### 9.Хэшируемые типы данных

            Хэшируемые типы данных — это объекты, которые имеют уникальный "хэш-код" (идентификатор). Такие объекты можно использовать как ключи в словарях или как элементы во множествах.
            
            - Хэшируемые объекты: неизменяемые типы данных. Примеры: строки (Str), числа (Int), кортежи (Tuple) (если внутри тоже хэшируемые объекты).
              
              Пример:
        </p>
        <pre>
            <code>
                my_dict = {1: "one", (1, 2): "tuple"}
                print(my_dict[(1, 2)])  # Кортеж используется как ключ              
            </code>
        </pre>
        <p>Не хэшируемые объекты: изменяемые типы данных. Примеры: списки (List), множества (Set), словари (Dict). 
            Их нельзя использовать как ключи в словарях или элементы во множествах.
        </p>
        <pre>
            <code>
                my_set = {1, 2, 3}
                # my_set.add([4, 5])  # Ошибка: список не хэшируемый и не может быть элементом множества                                        
            </code>
        </pre>
                    </div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        <footer class="footer bg-black small text-center text-white-50"><div class="container px-4 px-lg-5">Python One &copy; 2024</div></footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/script.js"></script>
        <script src="js/modal.js"></script>
    </body>
</html>
